<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BFS 미로 탐색</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #222;
        }
        .maze-container {
            display: grid;
            grid-template-columns: repeat(6, 40px);
            gap: 2px;
            background: #444;
            padding: 10px;
            border-radius: 10px;
        }
        .cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: white;
            font-weight: bold;
            transition: 0.3s;
            border-radius: 5px;
        }
        .wall { background: gray; }
        .path { background: blue; }
        .visited { background: lightblue; }
        .shortest { background: gold !important; }
        .start { background: green; }
        .end { background: red; }
    </style>
</head>
<body>

<div class="maze-container" id="maze"></div>

<script>
    const maze = [
        [1, 0, 1, 1, 1, 1],
        [1, 0, 1, 0, 1, 0],
        [1, 0, 1, 0, 1, 1],
        [1, 1, 1, 0, 1, 1]
    ];

    const N = maze.length;
    const M = maze[0].length;
    const dx = [-1, 1, 0, 0];
    const dy = [0, 0, -1, 1];

    const container = document.getElementById("maze");
    const cells = [];

    // HTML 요소 생성
    for (let i = 0; i < N; i++) {
        cells[i] = [];
        for (let j = 0; j < M; j++) {
            const cell = document.createElement("div");
            cell.classList.add("cell");
            if (maze[i][j] === 0) {
                cell.classList.add("wall");
                cell.innerText = "⬜";
            } else {
                cell.classList.add("path");
                cell.innerText = "🟦";
            }
            container.appendChild(cell);
            cells[i][j] = cell;
        }
    }
    cells[0][0].classList.add("start");
    cells[N-1][M-1].classList.add("end");

    // BFS 탐색
    async function bfs() {
        let queue = [[0, 0]];
        let visited = Array.from({ length: N }, () => Array(M).fill(false));
        let prev = Array.from({ length: N }, () => Array(M).fill(null));

        visited[0][0] = true;

        while (queue.length > 0) {
            let [x, y] = queue.shift();
            cells[x][y].classList.add("visited");
            await new Promise(res => setTimeout(res, 300)); // 0.3초 대기 (애니메이션 효과)

            if (x === N - 1 && y === M - 1) break; // 도착하면 종료

            for (let i = 0; i < 4; i++) {
                let nx = x + dx[i];
                let ny = y + dy[i];

                if (nx >= 0 && nx < N && ny >= 0 && ny < M && maze[nx][ny] === 1 && !visited[nx][ny]) {
                    visited[nx][ny] = true;
                    queue.push([nx, ny]);
                    prev[nx][ny] = [x, y];
                }
            }
        }

        // 최단 경로 추적
        let path = [];
        let x = N - 1, y = M - 1;
        while (x !== 0 || y !== 0) {
            path.push([x, y]);
            [x, y] = prev[x][y];
        }
        path.push([0, 0]);

        // 최단 경로 표시
        for (let [x, y] of path.reverse()) {
            cells[x][y].classList.add("shortest");
            await new Promise(res => setTimeout(res, 200));
        }
    }

    // 실행
    bfs();
</script>

</body>
</html>